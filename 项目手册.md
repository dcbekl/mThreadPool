# Index

## [class SafeQueue](#SafeQueue)

### 	[bool Empty()](#bool Empty())

### 	[int Size()](#int Size())

### [	void Push()](void Push)

## [namespace ErrorType](#namespace ErrorType)

## [class MTheadPoolError](#MTheadPoolError ) 

### 	[what](#char const* MTheadPoolError\<T\>::what() const)

## [class MThreadPool](#mThreadPool)

### 	[void start()](#void start())

### 	[void shutdown()](#void shutdown())

### 	[void addtask(std::function<void()> )](#void shutdown())

## [class mThreadWoker](#mThreadWorker)

## [class ManagerThread](#ManagerThread)

# **SafeQueue**

任务队列，负责存取任务。

```cpp
class SafeQueue
{
private:
    std::queue<T> m_queue; // 存放数据
    std::mutex m_mutex;	   // 互斥量
    
public:
	SafeQueue()  {}	// 空无参构造函数
	~SafeQueue() {} // 空析构函数

	// 判断队列是否为空
	bool Empty();

	// 返回队列中元素的个数
	int Size();

	// 向队列中添加中构造元素
	void Push (T t);
    
private:
	// 弹出队列中的一个元素
	T&& pop();
};
```

#### bool Empty()

判断队列是否为空

#### int Size()

返回队列中元素的个数

#### void Push()

向队列中添加中构造元素

### **namespace ErrorType**

```CPP
namespace ErrorType
{
    enum class SafeQueue // 来自 SafeQueue 的异常
    {
        empty			// 异常类型为empty
    };
}
```

# namespace ErrorType

> 自定义命名空间，存放线程池能抛出的异常对象。
>
> ```cpp
> enum class SafeQueue
> {
>     empty  // SafeQueue 为空异常
> };
> ```

# **MTheadPoolError**

自定义异常类

```cpp
template<typename T>
class MTheadPoolError : public std::exception {
public:
    MTheadPoolError(T _err_type) : err_type(_err_type) {};

    char const* what() const;  // 获取具体的错误信息


private:
    T err_type;     // 异常类型  ErroType中定义的枚举类
    std::stringstream ss;
};

```

## char const* MTheadPoolError\<T\>::what() const

返回自定义异常类的异常信息

# mThreadPool

> 线程池类
>
> ```c++
> class mThreadPool
> {
> private:
>     class mThreadWorker;		// 工作线程类
> 
> public:
>     
>     std::atomic<bool> m_stop;   // 是否关闭提交
> 
>     bool m_shutdown;            // 是否关闭线程池
> 
>     int free_thr_num;           // 工作线程的个数
>     
>     int thr_num;                // 线程池线程数目
>     
> public:
>     // 创建线程池
>     mThreadPool();
>     mThreadPool(int _thr_num);
> 
>     // 退出线程池
>     ~mThreadPool();
> 
>     // 启动线程池
>     void start();
> 
>     // 停止任务提交
>     void stop();
>    
>     // 重启任务提交
>  void restart();
>    
>     // 关闭线程池
>     void shutdown();
>    
>  // 添加任务
>     void addtask(std::function<void()> task) {}
>    };
> ```

## void start()

线程池启动函数。

> 当线程池的准备工作完成后，调用start函数，线程池即刻开始工作，去除任务队列中函数，并执行。

## void shutdown()

线程池关闭函数。

> 当不需要使用线程池的时候，调用shutdown函数，此时线程池将不再支持任务的添加。等任务队列中任务全部结束后，线程池释放所有开启的子线程。

## void addtask(std::function<void()> )

向线程池中添加任务，等待执行。

> std::function<void()>是任务的类型--仿函数，可以向线程中添加这种类型得到任务函数。

# mThreadWorker

> 工作线程，用以执行任务队列中的任务函数。
>
> ```c++
> class mThreadWorker {//内置线程工作类
> 
>     private:
>         int m_id; //工作id
> 
>         mThreadPool* m_pool;//所属线程池
> 
>     public:
>         //构造函数
>         mThreadWorker(mThreadPool* pool, const int id); // 所属线程池的对象的指针、工作线程的编号
> };
> ```

# **ManagerThread**

> 管理线程，复制线程的调度、析构。
>
> ```cpp
> // 内置管理类
> class ManagerThread
>     {
>     private:
>         mThreadPool* pool_ptr;		// 存放外部线程池对象的 this 指针
>     public:
>         ManagerThread(mThreadPool*);// 传入 ManagerThread 所属的线程池的指针
>     };
>    
> ```

# **参考链接：**

[C++ 线程池_c++线程池_破戒僧的博客-CSDN博客](https://blog.csdn.net/qq_34771252/article/details/90319537?ops_request_misc=&request_id=&biz_id=102&utm_term=c++线程池&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-90319537.142^v88^control_2,239^v2^insert_chatgpt&spm=1018.2226.3001.4187)

